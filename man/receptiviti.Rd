% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/receptiviti.R, R/receptiviti_status.R
\name{receptiviti}
\alias{receptiviti}
\alias{receptiviti_status}
\title{Receptiviti API}
\usage{
receptiviti(text, output = NULL, id = NULL, text_column = NULL,
  id_column = NULL, file_type = "txt", return_text = FALSE,
  frameworks = getOption("receptiviti_frameworks", "all"),
  framework_prefix = TRUE, as_list = FALSE, bundle_size = 1000,
  collapse_lines = FALSE, retry_limit = 10, clear_cache = FALSE,
  clear_scratch_cache = TRUE, request_cache = TRUE, cores = detectCores()
  - 1, use_future = FALSE, in_memory = TRUE, verbose = FALSE,
  overwrite = FALSE, compress = FALSE, make_request = TRUE,
  text_as_paths = FALSE, cache = Sys.getenv("RECEPTIVITI_CACHE"),
  cache_overwrite = FALSE,
  cache_format = Sys.getenv("RECEPTIVITI_CACHE_FORMAT", "parquet"),
  key = Sys.getenv("RECEPTIVITI_KEY"),
  secret = Sys.getenv("RECEPTIVITI_SECRET"),
  url = Sys.getenv("RECEPTIVITI_URL"))

receptiviti_status(url = Sys.getenv("RECEPTIVITI_URL"),
  key = Sys.getenv("RECEPTIVITI_KEY"),
  secret = Sys.getenv("RECEPTIVITI_SECRET"), verbose = TRUE,
  include_headers = FALSE)
}
\arguments{
\item{text}{A character vector with text to be processed, path to a directory containing files, or a vector of file paths.
If a single path to a directory, each file is collapsed to a single text. If a path to a file or files,
each line or row is treated as a separate text, unless \code{collapse_lines} is \code{TRUE}.}

\item{output}{Path to a \code{.csv} file to write results to. If this already exists, it will be loaded instead of
processing any text.}

\item{id}{Vector of unique IDs the same length as \code{text}, to be included in the results.}

\item{text_column, id_column}{Column name of text/id, if \code{text} is a matrix-like object, or a path to a csv file.}

\item{file_type}{File extension to search for, if \code{text} is the path to a directory containing files to be read in.}

\item{return_text}{Logical; if \code{TRUE}, \code{text} is included as the first column of the result.}

\item{frameworks}{A vector of frameworks to include results from. Texts are always scored with all available framework --
this just specifies what to return. Defaults to \code{all}, to return all scored frameworks. Can be set by the
\code{receptiviti_frameworks} option (e.g., \code{options(receptiviti_frameworks = c("liwc", "sallee"))}).}

\item{framework_prefix}{Logical; if \code{FALSE}, will remove the framework prefix from column names, which may result in duplicates.
If this is not specified, and 1 framework is selected, or \code{as_list} is \code{TRUE}, will default to remove prefixes.}

\item{as_list}{Logical; if \code{TRUE}, returns a list with frameworks in separate entries.}

\item{bundle_size}{Number of texts to include in each request; between 1 and 1,000.}

\item{collapse_lines}{Logical; if \code{TRUE}, and \code{text} contains paths to files, each file is treated as a single text.}

\item{retry_limit}{Maximum number of times each request can be retried after hitting a rate limit.}

\item{clear_cache}{Logical; if \code{TRUE}, will clear any existing files in the cache. Use \code{cache_overwrite} if
you want fresh results without clearing or disabling the cache. Use \code{cache = FALSE} to disable the cache.}

\item{clear_scratch_cache}{Logical; if \code{FALSE}, will preserve the bundles written when \code{in_memory} is \code{TRUE}, after
the request has been made.}

\item{request_cache}{Logical; if \code{FALSE}, will not}

\item{cores}{Number of CPU cores to split bundles across, if there are multiple bundles. See the Parallelization section.}

\item{use_future}{Logical; if \code{TRUE}, uses a \code{future} back-end to process bundles, in which case,
parallelization can be controlled with the \code{\link[future]{plan}} function (e.g., \code{plan("multisession")}
to use multiple cores); this is required to see progress bars when using multiple cores. See the Parallelization
section.}

\item{in_memory}{Logical; if \code{FALSE}, will write bundles to temporary files, and only load them as they are being requested.}

\item{verbose}{Logical; if \code{TRUE}, will show status messages.}

\item{overwrite}{Logical; if \code{TRUE}, will overwrite an existing \code{output} file.}

\item{compress}{Logical; if \code{TRUE}, will save as an \code{xz}-compressed file.}

\item{make_request}{Logical; if \code{FALSE}, a request is not made. This could be useful if you want to be sure and
load from one of the caches, but aren't sure that all results exist there; it will error out if it encounters
texts it has no other source for.}

\item{text_as_paths}{Logical; if \code{TRUE}, ensures \code{text} is treated as a vector of file paths. Otherwise, this will be
determined if there are no \code{NA}s in \code{text} and every entry is under 500 characters long.}

\item{cache}{Path to a directory in which to save unique results for reuse; defaults to \code{Sys.getenv("RECEPTIVITI_CACHE")}.
See the Cache section for details.}

\item{cache_overwrite}{Logical; if \code{TRUE}, will write results to the cache without reading from it. This could be used
if you want fresh results to be cached without clearing the cache.}

\item{cache_format}{Format of the cache database; see \code{\link[arrow]{FileFormat}}.
Defaults to \code{Sys.getenv("RECEPTIVITI_CACHE_FORMAT")}.}

\item{key}{API Key; defaults to \code{Sys.getenv("RECEPTIVITI_KEY")}.}

\item{secret}{API Secret; defaults to \code{Sys.getenv("RECEPTIVITI_SECRET")}.}

\item{url}{API endpoint; defaults to \code{Sys.getenv("RECEPTIVITI_URL")}, which defaults to
\code{"https://api.receptiviti.com/"}.}

\item{include_headers}{Logical; if \code{TRUE}, \code{receptiviti_status}'s verbose message will include
the HTTP headers.}
}
\value{
A \code{data.frame} with columns for \code{text} (if \code{return_text} is \code{TRUE}; the originally entered text),
\code{id} (if one was provided), \code{text_hash} (the MD5 hash of the text), and scores from each included framework
(e.g., \code{summary.word_count} and \code{liwc.i}). If \code{as_list} is \code{TRUE}, returns a list
with a named entry containing such a \code{data.frame} for each framework.
}
\description{
The main function to access the \href{https://www.receptiviti.com}{Receptiviti} API.
}
\section{Cache}{

By default, results for unique texts are saved in an \href{https://arrow.apache.org}{Arrow} database in the
cache location (\code{Sys.getenv("RECEPTIVITI_CACHE")}), and are retrieved with subsequent requests.
This ensures that the exact same texts are not re-sent to the API.
This does, however, add some processing time and disc space usage.

The \code{cache_format} arguments (or the \code{RECEPTIVITI_CACHE_FORMAT} environment variable) can be used to adjust the format of the cache.

You can use the cache independently with \code{open_database(Sys.getenv("RECEPTIVITI_CACHE"))}.

You can set the \code{cache} argument to \code{FALSE} to prevent the cache from being used, which might make sense if
you don't expect to need to reprocess it.

You can also set the \code{clear_cache} argument to \code{TRUE} to clear the cache before it is used again, which may be useful
if the cache has gotten big, or you know new results will be returned. Even if a cached result exists, it will be
reprocessed if it does not have all of the variables of new results, but this depends on there being at least 1 uncached
result. If, for instance, you add a framework to your account and want to reprocess a previously processed set of texts,
you would need to first clear the cache.

Either way, duplicated texts within the same call will only be sent once.

The \code{request_cache} argument controls a more temporary cache of each bundle request. This is cleared when the
R session ends. You might want to set this to \code{FALSE} if a new framework becomes available on your account
and you want to process a set of text you already processed in the current R session without restarting.

Another temporary cache is made when \code{in_memory} is \code{FALSE}, which is the default when processing
in parallel (when \code{cores} is over \code{1} or \code{use_future} is \code{TRUE}). This contains
a file for each unique bundle, which is read by as needed by the parallel workers.

For the final sort of cache, if \code{output} is specified, and the file already exists, it will be loaded instead of
a request being made.
}

\section{Parallelization}{

\code{text}s are split into bundles based on the \code{bundle_size} argument. Each bundle represents
a single request to the API, which is why they are limited to 1000 texts and a total size of 10 MB.
When there is more than one bundle and either \code{cores} is greater than 1 or \code{use_future} is \code{TRUE} (and you've
externally specified a \code{\link[future]{plan}}), bundles are processed by multiple cores.

Using \code{future} also allows for progress bars to be specified externally with \code{\link[progressr]{handlers}}; see examples.
}

\examples{
\dontrun{

# check that the API is available, and your credentials work
receptiviti_status()

# score a single text
single <- receptiviti("a text to score")

# score multiple texts, and write results to a file
multi <- receptiviti(c("first text to score", "second text"), "filename.csv")

# score many texts in separate files
## defaults to look for .txt files
file_results <- receptiviti("./path/to/txt_folder")

## could be .csv
file_results <- receptiviti(
  "./path/to/csv_folder",
  text_column = "text", file_type = "csv"
)

# score many texts from a file, with a progress bar
## set up cores and progress bar (only necessary if you want the progress bar)
future::plan("multisession")
progressr::handlers(global = TRUE)
progressr::handlers("progress")

## make request
results <- receptiviti(
  "./path/to/largefile.csv",
  text_column = "text", use_future = TRUE
)
}
}
